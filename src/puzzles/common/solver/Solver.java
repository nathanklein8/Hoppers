package puzzles.common.solver;
import java.util.*;

/**
 * Generic solver class to solve puzzles of different various configs
 *
 * @author Nathan Klein
 */
public class Solver {
    /** Hashmap of Configs to build the predecessor map*/
    HashMap<Configuration, Configuration> predecessorMap;
    /** LinkedList of configs that represents the queue*/
    LinkedList<Configuration> queue;
    /** the number of total configs created*/
    private int numConfigs = 1;
    /** the number of unique configs generated*/
    private int uniqueConfigs;

    /**
     * returns the total number of configurations generated by the Solver
     * should only be called after solve() has been called
     * @return int - total number of configurations generated
     */
    public int getNumConfigs() {
        return numConfigs;
    }

    /**
     * returns the number of unique configurations generated by the Solver
     * should only be called after solve() has been called
     * @return int - number of Unique configurations
     */
    public int getUniqueConfigs() {
        return uniqueConfigs;
    }

    /**
     * Constructs a new solver with a new hashmap and linkedlist
     */
    public Solver() {
        this.predecessorMap = new HashMap<>();
        this.queue = new LinkedList<>();
    }

    /**
     * finds the shortest path to a configuration that is a valid solution
     * @param configuration starting configuration to solve
     * @return LinkedList of Configurations that represent the shortest path to a valid solution
     */
    public LinkedList<Configuration> solve(Configuration configuration) {
        queue.add(configuration);
        predecessorMap.put(configuration, null);
        Configuration next = queue.remove(0);
        //  BUILDING THE PREDECESSOR MAP
        while (!next.isSolution()) {
            Collection<Configuration> neighbors = next.getNeighbors();
            numConfigs += neighbors.size();
            for (Configuration c : neighbors) {
                if (!predecessorMap.containsKey(c)) {
                    queue.add(c);
                    predecessorMap.put(c, next);
                }
            }
            if (queue.isEmpty()) { // if there is no solution
                uniqueConfigs = predecessorMap.size();
                return new LinkedList<>();
            } else { // there stuff in the queue so there might be a solution
                next = queue.remove(0);
            }
        }
        //
        //  GOES BACK THROUGH THE PREDECESSOR MAP TO FIND THE SHORTEST PATH
        //
        Configuration step = next;
        LinkedList<Configuration> path = new LinkedList<>();
        while (predecessorMap.get(step) != null) {
            path.add(0, step);
            step = predecessorMap.get(step);
        }
        path.add(0, step);
        uniqueConfigs = predecessorMap.size();
        return path;
    }

}
